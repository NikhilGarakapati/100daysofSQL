# 100daysofSQL

- The purpose of accepting this challenge is to dive deep in Querying concepts starting from basic SQL problem solving 
to performance tuning, query optimization etc.,

- This repository would contain the `Python` way of solving the problems.


---
## Day1

**Problem statement:**

Write a query that calculates the difference between the highest salaries found in the marketing and engineering departments. Output just the difference in salaries.

**Data Structure:**
[view here](https://github.com/NikhilGarakapati/100daysofSQL/blob/main/datasets/Day1/data_model.PNG)

**Datasets:**
[view here](https://github.com/NikhilGarakapati/100daysofSQL/tree/main/datasets/Day1)


**Solution1:** [view here](https://github.com/NikhilGarakapati/100daysofSQL/tree/main/sql/day1)


---
## Day2
**Problem statement:**

Find the date with the highest total energy consumption from the data centers. Output the date along with the total energy consumption across all data centers.

**Data model:** [view here](https://github.com/NikhilGarakapati/100daysofSQL/blob/main/datasets/Day2/data_model.PNG)

**Datasets** [view here](https://github.com/NikhilGarakapati/100daysofSQL/tree/main/datasets/Day2)

**Solution:** [view here](https://github.com/NikhilGarakapati/100daysofSQL/tree/main/sql/day2)

---
## Day3
**Problem statement:**
Find the total number of downloads for paying and non-paying users by date. Include only records where non-paying customers have more downloads than paying customers. The output should be sorted by earliest date first and contain 3 columns date, non-paying downloads, paying downloads.

**Datasets:** [view here](https://github.com/NikhilGarakapati/100daysofSQL/tree/main/datasets/Day3)

**Solution:** [view here](https://github.com/NikhilGarakapati/100daysofSQL/blob/main/sql/day3/paying_and_non_paying1.sql)

---
## Day4
**Problem statement:**
Find the popularity percentage for each user on Facebook. The popularity percentage is defined as the total number of friends the user has divided by the total number of users on the platform, then converted into a percentage by multiplying by 100.
Output each user along with their popularity percentage. Order records in ascending order by user id.
The 'user1' and 'user2' column are pairs of friends.

**Datasets:** [view here](https://github.com/NikhilGarakapati/100daysofSQL/tree/main/datasets/Day4)

**Solution:** [view here](https://github.com/NikhilGarakapati/100daysofSQL/blob/main/sql/day4/facebook_users1.sql)

---
## Day5
**Problem statement:**
Write a query that'll identify returning active users. A returning active user is a user that has made a second purchase within 7 days of any other of their purchases. Output a list of user_ids of these returning active users.

**Datasets**: [view here](https://github.com/NikhilGarakapati/100daysofSQL/tree/main/datasets/Day5)

**Solution:** [view here](https://github.com/NikhilGarakapati/100daysofSQL/blob/main/sql/day5/user_purchases.sql)

## Day6
**Problem statement:** [view here](https://leetcode.com/problems/department-top-three-salaries/)

**Solution:** [view here](https://leetcode.com/problems/delete-duplicate-emails/discuss/1527807/mysql-faster-than-9866)

## Day7

### Exploring Booking.com dataset